#include <Arduino.h>
#include <LittleFS.h>
#include "tensorflow/lite/micro/micro_mutable_op_resolver.h"
#include "tensorflow/lite/micro/micro_interpreter.h"
#include "tensorflow/lite/micro/system_setup.h"
#include "tensorflow/lite/schema/schema_generated.h"
#include "tensorflow/lite/micro/micro_error_reporter.h"

// TFLite globals
namespace
{
  const tflite::Model *model = nullptr;
  tflite::MicroInterpreter *interpreter = nullptr;
  TfLiteTensor *input = nullptr;
  TfLiteTensor *output = nullptr;

  constexpr int kTensorArenaSize = 5 * 1024 * 1024; // 5 MB
  uint8_t *tensor_arena = nullptr;
}

void setup()
{
  Serial.begin(115200);
  delay(2000);

  Serial.println("\nğŸ§  MoodLink - Test TFLite (Fase 1)");
  Serial.println("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

  // 1. Montar LittleFS
  Serial.println("\nğŸ“‚ Montando LittleFS...");
  if (!LittleFS.begin(true))
  {
    Serial.println("âŒ Error montando LittleFS");
    while (1)
      ;
  }
  Serial.println("âœ… LittleFS OK");

  // 2. Cargar modelo
  Serial.println("\nğŸ“¦ Cargando modelo...");
  File modelFile = LittleFS.open("/ser_cnn_int8.tflite", "r");
  if (!modelFile)
  {
    Serial.println("âŒ No se pudo abrir modelo");
    while (1)
      ;
  }

  size_t modelSize = modelFile.size();
  Serial.printf("   TamaÃ±o: %d bytes\n", modelSize);

  uint8_t *modelBuffer = (uint8_t *)ps_malloc(modelSize);
  if (!modelBuffer)
  {
    Serial.println("âŒ No hay PSRAM para modelo");
    while (1)
      ;
  }

  modelFile.read(modelBuffer, modelSize);
  modelFile.close();
  Serial.println("âœ… Modelo cargado en PSRAM");

  // 3. Inicializar TFLite
  Serial.println("\nğŸ”§ Inicializando TFLite...");

  model = tflite::GetModel(modelBuffer);
  if (model->version() != TFLITE_SCHEMA_VERSION)
  {
    Serial.printf("âŒ VersiÃ³n incorrecta: modelo=%d, esperado=%d\n",
                  model->version(), TFLITE_SCHEMA_VERSION);
    while (1)
      ;
  }
  Serial.println("âœ… Modelo compatible");

  // 4. Crear OpResolver
  static tflite::MicroMutableOpResolver<10> resolver;
  resolver.AddConv2D();
  resolver.AddMaxPool2D();
  resolver.AddFullyConnected();
  resolver.AddSoftmax();
  resolver.AddReshape();
  resolver.AddMean();
  resolver.AddQuantize();
  resolver.AddDequantize();
  resolver.AddMul();
  resolver.AddAdd();
  Serial.println("âœ… OpResolver configurado");

  // 5. Reservar tensor arena
  tensor_arena = (uint8_t *)heap_caps_aligned_alloc(16, kTensorArenaSize, MALLOC_CAP_SPIRAM);
  if (!tensor_arena)
  {
    Serial.println("âŒ No hay PSRAM para tensor arena");
    while (1)
      ;
  }

  // Verificar alineaciÃ³n
  if (((uintptr_t)tensor_arena % 16) != 0)
  {
    Serial.println("âŒ Tensor arena no alineado");
    while (1)
      ;
  }

  Serial.printf("âœ… Tensor arena: %d KB (alineado a 16 bytes)\n", kTensorArenaSize / 1024);
  Serial.printf("   DirecciÃ³n: 0x%08x\n", (uintptr_t)tensor_arena);
  Serial.printf("   TamaÃ±o: %d bytes\n", kTensorArenaSize);
  // 6. Crear intÃ©rprete
  static tflite::ErrorReporter *error_reporter = tflite::GetMicroErrorReporter();

  static tflite::MicroInterpreter static_interpreter(
      model, resolver, tensor_arena, kTensorArenaSize, error_reporter);

  interpreter = &static_interpreter;

  TfLiteStatus allocate_status = interpreter->AllocateTensors();
  if (allocate_status != kTfLiteOk)
  {
    Serial.println("âŒ Error al asignar tensors");
    while (1)
      ;
  }
  Serial.println("âœ… IntÃ©rprete creado");

  // 7. Verificar tensors
  input = interpreter->input(0);
  output = interpreter->output(0);

  Serial.println("\nğŸ“ InformaciÃ³n del modelo:");
  Serial.printf("   Input dims: %d\n", input->dims->size);
  for (int i = 0; i < input->dims->size; i++)
  {
    Serial.printf("      [%d] = %d\n", i, input->dims->data[i]);
  }

  Serial.printf("   Output dims: %d\n", output->dims->size);
  for (int i = 0; i < output->dims->size; i++)
  {
    Serial.printf("      [%d] = %d\n", i, output->dims->data[i]);
  }

  Serial.println("\nâœ… FASE 1 COMPLETADA");
  Serial.println("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
}

void loop()
{
  delay(1000);
}
